#!/usr/bin/env python3
import sys
import subprocess
from PyQt6.QtWidgets import QApplication, QMainWindow, QWidget, QHBoxLayout, QPushButton, QFrame, QVBoxLayout, QSlider, QStackedWidget
from PyQt6.QtGui import QPixmap, QPainter, QPen, QColor, QBrush, QFont, QLinearGradient, QKeySequence
from PyQt6.QtCore import Qt, QPoint, QRect, QBuffer, QIODevice, pyqtSignal

class Shape:
    def __init__(self, rect, kind, color, label=None, strength=None):
        self.rect = rect
        self.kind = kind
        self.color = color
        self.label = label
        self.strength = strength

# --- LE NOUVEAU WIDGET DE PALETTE ---
class ColorPicker(QWidget):
    colorChanged = pyqtSignal(QColor)

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setFixedSize(200, 20)
        self.current_hue = 0

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        
        # Dessin du dégradé Arc-en-ciel
        gradient = QLinearGradient(0, 0, self.width(), 0)
        for i in range(0, 360, 10):
            gradient.setColorAt(i/360, QColor.fromHsv(i, 200, 255))
        
        painter.setPen(Qt.PenStyle.NoPen)
        painter.setBrush(QBrush(gradient))
        painter.drawRoundedRect(self.rect(), 10, 10)

        # Curseur blanc
        cursor_x = (self.current_hue / 360) * self.width()
        cursor_y = self.height() // 2
        cursor_r = max(4, self.height() // 3)
        painter.setPen(QPen(Qt.GlobalColor.white, 2))
        painter.setBrush(Qt.BrushStyle.NoBrush)
        painter.drawEllipse(QPoint(int(cursor_x), cursor_y), cursor_r, cursor_r)

    def mouseMoveEvent(self, event):
        self.update_color(event.pos())

    def mousePressEvent(self, event):
        self.update_color(event.pos())

    def update_color(self, pos):
        hue = max(0, min(359, int((pos.x() / self.width()) * 359)))
        self.current_hue = hue
        self.colorChanged.emit(QColor.fromHsv(hue, 200, 255))
        self.update()

# --- L'ÉDITEUR PRINCIPAL ---
class MiniEditor(QMainWindow):
    def __init__(self, binary_data):
        super().__init__()
        self.setWindowFlags(Qt.WindowType.FramelessWindowHint | Qt.WindowType.WindowStaysOnTopHint)
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
        self.setFocusPolicy(Qt.FocusPolicy.StrongFocus)

        self.pixmap = QPixmap()
        self.pixmap.loadFromData(binary_data)
        
        self.compute_ui_metrics()
        window_width = max(self.pixmap.width(), self.min_window_width)
        self.setFixedSize(window_width, self.pixmap.height() + self.TB_HEIGHT)
        self.image_offset_x = (window_width - self.pixmap.width()) // 2
        self.image_rect = QRect(self.image_offset_x, self.TB_HEIGHT, self.pixmap.width(), self.pixmap.height())

        self.tool_colors = {
            "SELECT": QColor("#f38ba8"), "DRAW_RECT": QColor("#f38ba8"),
            "DRAW_CIRCLE": QColor("#f38ba8"), "OBFUSCATE": QColor("#585b70"),
            "HIGHLIGHT": QColor("#f38ba8"), "INDEX": QColor("#f38ba8")
        }

        self.shapes = []        
        self.current_shape = None
        self.selected_shape = None
        self.mode = "DRAW_RECT"
        self.drag_start_pos = None
        self.index_counter = 1
        self.obfuscation_strength = 4

        self.init_ui()
        self.set_mode("DRAW_RECT")

    def init_ui(self):
        self.main_container = QWidget(self)
        self.main_container.setFixedSize(self.size())
        
        # BARRE D'OUTILS (QFrame pour le style)
        self.toolbar_bg = QFrame(self.main_container)
        self.toolbar_bg.setGeometry(0, 0, self.width(), self.TB_HEIGHT)
        self.toolbar_bg.setStyleSheet("background-color: #11111b; border-bottom: 1px solid #313244;")

        # Layout horizontal pour les boutons et la palette
        self.layout = QHBoxLayout(self.toolbar_bg)
        self.layout.setContentsMargins(self.margin, 0, self.margin, 0)
        self.layout.setSpacing(self.spacing)
        
        # Groupe Outils (Gauche)
        self.tool_buttons = {}
        for icon, mode in [("▭", "DRAW_RECT"), ("◯", "DRAW_CIRCLE"), ("▒", "OBFUSCATE"), ("󰏫", "HIGHLIGHT")]:
            btn = QPushButton(icon)
            btn.setFixedSize(self.btn_size, self.btn_size)
            btn.clicked.connect(lambda checked, m=mode: self.set_mode(m))
            self.layout.addWidget(btn)
            self.tool_buttons[mode] = btn

        self.layout.addStretch()

        # LA PALETTE (Milieu)
        self.picker_stack = QStackedWidget()
        self.picker_stack.setFixedSize(self.picker_width, self.picker_height)

        self.picker = ColorPicker()
        self.picker.setFixedSize(self.picker_width, self.picker_height)
        self.picker.colorChanged.connect(self.change_tool_color)

        self.obfuscation_slider = QSlider(Qt.Orientation.Horizontal)
        self.obfuscation_slider.setFixedSize(self.picker_width, self.picker_height)
        self.obfuscation_slider.setRange(2, 16)
        self.obfuscation_slider.setValue(self.obfuscation_strength)
        self.obfuscation_slider.valueChanged.connect(self.change_obfuscation_strength)

        self.picker_stack.addWidget(self.picker)
        self.picker_stack.addWidget(self.obfuscation_slider)
        self.layout.addWidget(self.picker_stack)

        self.layout.addStretch()

        # Groupe Actions (Droite)
        for icon, func, color in [("✕", self.close_window, "#f38ba8"), ("󰄬", self.finish_and_copy, "#a6e3a1")]:
            btn = QPushButton(icon)
            btn.setFixedSize(self.btn_size, self.btn_size)
            btn.setStyleSheet(
                f"color: {color}; border-radius: {self.radius}px; font-size: {self.font_size}px; "
                "background: #313244; border: none;"
            )
            btn.clicked.connect(func)
            self.layout.addWidget(btn)

    def compute_ui_metrics(self):
        self.min_window_width = 400
        min_dim = min(self.pixmap.width(), self.pixmap.height())
        scale = max(0.7, min(1.4, min_dim / 900))
        self.btn_size = int(42 * scale)
        self.font_size = int(20 * scale)
        self.radius = int(10 * scale)
        self.margin = int(20 * scale)
        self.spacing = int(15 * scale)
        self.picker_width = int(200 * scale)
        self.picker_height = int(20 * scale)
        self.TB_HEIGHT = max(int(70 * scale), self.btn_size + int(20 * scale))

    def set_mode(self, mode):
        self.mode = mode
        if mode == "INDEX":
            # Index mode should not alter existing shapes.
            self.current_shape = None
            self.selected_shape = None
        if mode == "OBFUSCATE":
            self.picker_stack.setCurrentWidget(self.obfuscation_slider)
        else:
            self.picker_stack.setCurrentWidget(self.picker)
        for m, btn in self.tool_buttons.items():
            color = self.tool_colors[m].name()
            bg = "#313244" if m == mode else "transparent"
            border = f"1px solid {color}" if m == mode else "none"
            btn.setStyleSheet(
                f"background-color: {bg}; color: {color}; border: {border}; "
                f"border-radius: {self.radius}px; font-size: {self.font_size}px; "
                "padding: 0px; text-align: center;"
            )
        
        # Mettre à jour la palette pour l'outil sélectionné
        h, s, v, a = self.tool_colors[self.mode].getHsv()
        if h != -1: self.picker.current_hue = h
        self.picker.update()

    def change_tool_color(self, color):
        if self.mode != "OBFUSCATE":
            # On garde l'alpha si c'est le highlight
            if self.mode == "HIGHLIGHT": color.setAlpha(120)
            
            self.tool_colors[self.mode] = color
            if self.selected_shape:
                self.selected_shape.color = color
            self.set_mode(self.mode) # Refresh les couleurs des boutons
            self.update()

    def change_obfuscation_strength(self, value):
        self.obfuscation_strength = value
        self.update()

    def mousePressEvent(self, event):
        if event.pos().y() < self.TB_HEIGHT: return
        if not self.image_rect.contains(event.pos()): return

        if self.mode == "INDEX":
            radius = 16
            center_x = max(self.image_rect.left() + radius, min(event.pos().x(), self.image_rect.right() - radius))
            center_y = max(self.image_rect.top() + radius, min(event.pos().y(), self.image_rect.bottom() - radius))
            rect = QRect(center_x - radius, center_y - radius, radius * 2, radius * 2)
            color = QColor(self.tool_colors[self.mode])
            self.shapes.append(Shape(rect, "INDEX", color, str(self.index_counter)))
            self.index_counter += 1
        elif self.mode == "SELECT":
            self.selected_shape = None
            for s in reversed(self.shapes):
                if s.rect.contains(event.pos()):
                    self.selected_shape = s
                    self.drag_start_pos = event.pos()
                    break
        else:
            color = QColor(self.tool_colors[self.mode])
            strength = self.obfuscation_strength if self.mode == "OBFUSCATE" else None
            self.current_shape = Shape(QRect(event.pos(), event.pos()), self.mode, color, strength=strength)
            self.shapes.append(self.current_shape)
        self.update()

    def mouseMoveEvent(self, event):
        if event.buttons() & Qt.MouseButton.LeftButton:
            if self.mode == "INDEX":
                return
            if self.mode == "SELECT" and self.selected_shape:
                delta = event.pos() - self.drag_start_pos
                self.selected_shape.rect.translate(delta)
                self.drag_start_pos = event.pos()
            elif self.current_shape:
                clamped = QPoint(
                    max(self.image_rect.left(), min(event.pos().x(), self.image_rect.right())),
                    max(self.image_rect.top(), min(event.pos().y(), self.image_rect.bottom())),
                )
                self.current_shape.rect.setBottomRight(clamped)
            self.update()

    def paintEvent(self, event):
        # Compose everything offscreen so obfuscation affects prior shapes too.
        canvas = QPixmap(self.size())
        canvas.fill(Qt.GlobalColor.transparent)
        canvas_painter = QPainter(canvas)
        canvas_painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        canvas_painter.drawPixmap(self.image_offset_x, self.TB_HEIGHT, self.pixmap)

        image_rect = self.image_rect

        for s in self.shapes:
            if s.kind == "OBFUSCATE":
                # Pixelate the current composed content (image + prior shapes).
                target_rect = s.rect.intersected(image_rect)
                if not target_rect.isEmpty():
                    region = canvas.copy(target_rect)
                    # Fixed pixel size for consistent obfuscation strength.
                    pixel = s.strength if s.strength is not None else self.obfuscation_strength
                    small = region.scaled(
                        max(1, region.width() // pixel),
                        max(1, region.height() // pixel),
                        Qt.AspectRatioMode.IgnoreAspectRatio,
                        Qt.TransformationMode.FastTransformation,
                    )
                    pixelated = small.scaled(
                        region.width(),
                        region.height(),
                        Qt.AspectRatioMode.IgnoreAspectRatio,
                        Qt.TransformationMode.FastTransformation,
                    )
                    canvas_painter.drawPixmap(target_rect.topLeft(), pixelated)
            elif s.kind == "HIGHLIGHT":
                canvas_painter.setBrush(QBrush(s.color))
                canvas_painter.setPen(Qt.PenStyle.NoPen)
                canvas_painter.drawRect(s.rect)
            elif s.kind == "INDEX":
                canvas_painter.setBrush(QBrush(s.color))
                canvas_painter.setPen(Qt.PenStyle.NoPen)
                canvas_painter.drawEllipse(s.rect)
                font = QFont(self.font().family(), max(8, int(s.rect.height() * 0.6)))
                font.setBold(True)
                canvas_painter.setFont(font)
                canvas_painter.setPen(QPen(Qt.GlobalColor.white))
                canvas_painter.drawText(s.rect, Qt.AlignmentFlag.AlignCenter, s.label or "")
            else:
                canvas_painter.setPen(QPen(s.color, 3))
                canvas_painter.setBrush(Qt.BrushStyle.NoBrush)
                if s.kind == "DRAW_CIRCLE":
                    canvas_painter.drawEllipse(s.rect)
                else:
                    canvas_painter.drawRect(s.rect)

        canvas_painter.end()

        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        painter.drawPixmap(0, 0, canvas)

        if self.selected_shape:
            painter.setPen(QPen(QColor(255, 255, 255, 180), 1, Qt.PenStyle.DashLine))
            painter.drawRect(self.selected_shape.rect.adjusted(-2, -2, 2, 2))

    def delete_selected(self):
        if self.selected_shape:
            self.shapes.remove(self.selected_shape)
            self.selected_shape = None
            self.update()

    def close_window(self):
        self.close()

    def finish_and_copy(self):
        self.selected_shape = None
        self.toolbar_bg.hide()
        self.update()
        QApplication.processEvents()
        final_rect = QRect(self.image_offset_x, self.TB_HEIGHT, self.pixmap.width(), self.pixmap.height())
        screenshot = self.grab(final_rect)
        buffer = QBuffer()
        buffer.open(QIODevice.OpenModeFlag.WriteOnly)
        screenshot.save(buffer, "PNG")
        subprocess.run(["wl-copy", "--type", "image/png"], input=buffer.data().data(), check=True)
        self.close()

    def keyPressEvent(self, event):
        if event.matches(QKeySequence.StandardKey.Copy) or (
            event.modifiers() & Qt.KeyboardModifier.ControlModifier
            and event.key() == Qt.Key.Key_C
        ):
            self.finish_and_copy()
            event.accept()
            return
        if event.key() == Qt.Key.Key_R:
            self.set_mode("DRAW_RECT")
            event.accept()
            return
        if event.key() == Qt.Key.Key_C and event.modifiers() == Qt.KeyboardModifier.NoModifier:
            self.set_mode("DRAW_CIRCLE")
            event.accept()
            return
        if event.key() == Qt.Key.Key_I and event.modifiers() == Qt.KeyboardModifier.NoModifier:
            self.set_mode("INDEX")
            event.accept()
            return
        if event.key() == Qt.Key.Key_O:
            self.set_mode("OBFUSCATE")
            event.accept()
            return
        if event.key() == Qt.Key.Key_H:
            self.set_mode("HIGHLIGHT")
            event.accept()
            return
        if event.key() == Qt.Key.Key_Escape:
            self.close()
            event.accept()
            return
        super().keyPressEvent(event)

if __name__ == "__main__":
    input_data = sys.stdin.buffer.read()
    if not input_data: sys.exit(0)
    app = QApplication(sys.argv)
    app.setFont(QFont("JetBrainsMono Nerd Font", 10))
    editor = MiniEditor(input_data)
    editor.show()
    sys.exit(app.exec())
